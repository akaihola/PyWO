#!/usr/bin/env python
#
# PyWO - Python Window Organizer
# Copyright 2010, Wojciech 'KosciaK' Pietrzok
#
# This file is part of PyWO.
#
# PyWO is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# PyWO is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with PyWO.  If not, see <http://www.gnu.org/licenses/>.
#

"""pywo.py - main module for PyWO."""

#import atexit
import logging
from logging.handlers import RotatingFileHandler
import signal
import threading
import time
import sys

import actions
import commandline
from config import Config
from core import Window, WindowManager
import services


__author__ = "Wojciech 'KosciaK' Pietrzok <kosciak@kosciak.net>"
__version__ = "0.3"


WM = WindowManager()

# TODO: consider moving it to services.main or __init__
#       it is almost normal service anyway, with setup, start and stop
#       in pywo.py leave only parsing commandline arguments
SERVICES = []


def setup_loggers(debug=False):
    """Setup file, and console loggers."""
    logger = logging.getLogger()
    logger.setLevel(logging.DEBUG)
    format = '%(levelname)s: %(filename)s(%(lineno)d) %(funcName)s: %(message)s'
    rotating = RotatingFileHandler('/tmp/PyWO.log', 'a', 1024*50, 2)
    rotating.setFormatter(logging.Formatter(format))
    rotating.setLevel(logging.DEBUG)
    logger.addHandler(rotating)
    console = logging.StreamHandler()
    if debug:
        console.setLevel(logging.DEBUG)
    else:
        console.setLevel(logging.INFO)
    logger.addHandler(console)


def start(config):
    """Setup and start all services."""
    global SERVICES
    SERVICES = []
    for service in services.all(config):
        SERVICES.append(service)
    for service in SERVICES:
        service.setup(config)
        service.start()
    logging.info('PyWO ready and running!')


def stop():
    """Stop all services."""
    for service in SERVICES:
        service.stop()


def reload(win, config=None, *args):
    """Stop services, reload configuration file, and start again."""
    logging.info('Reloading PyWO...')
    stop()
    logging.info('Reloading configuration file')
    global FILENAME
    FILENAME = config or FILENAME
    config = Config(FILENAME)
    start(config)


def exit_pywo(*args):
    """Stop sevices, and exit PyWO."""
    logging.info('Exiting PyWO...')
    stop() # stop all services
    WM.unlisten_all() # unregister all remaining EventHandlers


#atexit.register(stop)

def interrupt_handler(sig, frame):
    """Handle signal generated by Ctrl-C and kill signal."""
    logging.error('Interrupted!')
    signal.signal(signal.SIGINT, signal.SIG_IGN)
    signal.signal(signal.SIGTERM, signal.SIG_IGN)
    exit_pywo(True)

signal.signal(signal.SIGINT, interrupt_handler)
signal.signal(signal.SIGTERM, interrupt_handler)


if __name__ == '__main__':
    # parse commandline
    try:
        (options, args) = commandline.parse_args()
    except commandline.ParserException, e:
        commandline.print_error(str(e))
    # setup loggers
    setup_loggers(options.debug)
    global FILENAME
    FILENAME = options.config
    config = Config(FILENAME)

    if options.start_daemon:
        logging.info('Starting PyWO...')
        actions.register(name='exit')(exit_pywo)
        actions.register(name='reload')(reload)
        start(config)
        while len(threading.enumerate()) > 1: 
            # just keep the MainThread busy for Ctrl-C to work
            time.sleep(0.5)
    elif options.list_windows:
        windows = WM.windows(lambda window: Window.TYPE_NORMAL in window.type)
        for window in windows:
            geometry = window.geometry
            state = window.state
            win_desktop = window.desktop
            desktop = [win_desktop, -1][Window.STATE_STICKY in state or \
                                         win_desktop == Window.ALL_DESKTOPS]
            if Window.STATE_FULLSCREEN in state:
                state_flags = 'F'
            elif Window.STATE_MAXIMIZED_HORZ in state and \
                 Window.STATE_MAXIMIZED_VERT in state:
                state_flags = 'M'
            elif Window.STATE_MAXIMIZED_VERT in state:
                state_flags = 'V'
            elif Window.STATE_MAXIMIZED_HORZ in state:
                state_flags = 'H'
            elif Window.STATE_HIDDEN in state:
                state_flags = 'i'
            else:
                state_flags = ' '
            state_flags += [' ', 's'][Window.STATE_SHADED in state and \
                                      not Window.STATE_HIDDEN in state]
            print '%s %s %s %s' % (window.id, desktop, state_flags, window.name)
    #elif options.list_desktops:
    #    print 'Not implemented yet...'
    elif args or options.action:
        try:
            actions.perform(args, config, options)
            WM.flush()
        except actions.ActionException, e:
            # TODO: What about other exceptions?
            #       parser exceptions?
            commandline.print_error(e)
    elif options.help_more:
        commandline.print_help_more(config)
    else:
        commandline.print_help()

